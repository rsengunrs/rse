import str from "string-to-stream";
import { PNG } from "pngjs/browser";

import { imagenetClasses } from "./imagenet";
import {
	Tensor,
	InferenceSession,
	TensorType,
} from "@cloudflare/constellation";

export default {
	async fetch(request: Request, env: Env): Promise<Response> {
		if (request.method == "POST") {
			const formData = await request.formData();
			if (formData) {
				const file = formData.get("file") as unknown as File;
				if (file) {
					const data = await file.arrayBuffer();
					const result = await processImage(env, data);
					return new Response(JSON.stringify(result));
				}
			}
		}
		const { searchParams } = new URL(request.url);
		let image = searchParams.get("image");
		if (image) {
			const res = await fetch(image);
			const blob = await res.arrayBuffer();
			const result = await processImage(env, blob);
			return new Response(
				`<html><body><img src="${image}"><br/><pre>${JSON.stringify(
					result,
				)}</pre></body></html>`,
				{
					headers: {
						"content-type": "text/html;charset=UTF-8",
					},
				},
			);
		}

		return new Response(
			`try uploading a 224x244 PNG image with:\n\ncurl ${
				env.ENVIRONMENT == "dev"
					? `http://127.0.0.1:9000`
					: "https://ai.cloudflare.com/demos/image-classifier"
			} -F file=@images/cat.png`,
		);
	},
};

async function processImage(env: Env, data: ArrayBuffer) {
	let result;

	const input = await decodeImage(data).catch((err) => {
		result = err;
	});

	if (input) {
		const session = new InferenceSession(
			env.CLASSIFIER,
			"8785280e-86be-4b08-99ea-2b42bbff6d25",
		);
		const tensorInput = new Tensor(TensorType.Float32, input, {
			shape: [1, 3, 224, 224],
		});
		const predictionTensor = Object.values(await session.run([tensorInput]))[0];
		const softmaxResult = softmax(predictionTensor.value);
		const results = topClasses(softmaxResult, 5);

		result = results[0];
	}

	return result;
}

/* The model expects input images normalized in the same way, i.e. mini-batches of 3-channel RGB images
   of shape (N x 3 x H x W), where N is the batch size, and H and W are expected to be 224. */

async function decodeImage(
	buffer: ArrayBuffer,
	width: number = 224,
	height: number = 224,
): Promise<any> {
	return new Promise(async (ok, err) => {
		// convert string to stream
		const stream: any = str(buffer as unknown as string);

		stream
			.pipe(
				new PNG({
					filterType: 4,
				}),
			)
			.on("parsed", function (this: any) {
				if (this.width != width || this.height != height) {
					err({
						err: `expected width to be ${width}x${height}, given ${this.width}x${this.height}`,
					});
				} else {
					const [redArray, greenArray, blueArray] = new Array(
						new Array<number>(),
						new Array<number>(),
						new Array<number>(),
					);

					for (let i = 0; i < this.data.length; i += 4) {
						redArray.push(this.data[i] / 255.0);
						greenArray.push(this.data[i + 1] / 255.0);
						blueArray.push(this.data[i + 2] / 255.0);
						// skip data[i + 3] to filter out the alpha channel
					}

					const transposedData = redArray.concat(greenArray).concat(blueArray);
					ok(transposedData);
				}
			})
			.on("error", function (error: any) {
				err({ err: error.toString() });
			});
	});
}

// See https://en.wikipedia.org/wiki/Softmax_function
// Transforms values to between 0 and 1
// The sum of all outputs generated by softmax is 1.

function softmax(resultArray: number[]): any {
	const largestNumber = Math.max(...resultArray);
	const sumOfExp = resultArray
		.map((resultItem) => Math.exp(resultItem - largestNumber))
		.reduce((prevNumber, currentNumber) => prevNumber + currentNumber);
	return resultArray.map((resultValue) => {
		return Math.exp(resultValue - largestNumber) / sumOfExp;
	});
}

/* Get the top n classes from ImagetNet */

export function topClasses(classProbabilities: any, n = 5) {
	const probabilities = ArrayBuffer.isView(classProbabilities)
		? Array.prototype.slice.call(classProbabilities)
		: classProbabilities;

	const sorted = probabilities
		.map((prob: any, index: number) => [prob, index])
		.sort((a: Array<number>, b: Array<number>) => {
			return a[0] == b[0] ? 0 : a[0] > b[0] ? -1 : 1;
		});

	const top = sorted.slice(0, n).map((probIndex: Array<number>) => {
		const iClass = imagenetClasses[probIndex[1]];
		return {
			id: iClass[0],
			index: parseInt(probIndex[1].toString(), 10),
			name: iClass[1].replace(/_/g, " "),
			probability: probIndex[0],
		};
	});

	return top;
}

export interface Env {
	CLASSIFIER: any;
	ENVIRONMENT: any;
}
